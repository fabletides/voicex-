#ifndef VOICEX_MODEL_DATA_H
#define VOICEX_MODEL_DATA_H

/*
 * VoiceX Model Data
 * Автоматически сгенерированный файл с встроенной TensorFlow Lite моделью
 * 
 * Этот файл содержит минимальную демо-модель для тестирования.
 * Для продакшена замените на обученную модель через скрипт:
 * python scripts/create_model_header.py --model model.tflite --output model_data.h
 */

#include <stdint.h>

// Размер модели в байтах
const unsigned int voicex_model_data_len = 2896;

// Данные модели (минимальная тестовая модель)
const unsigned char voicex_model_data[] = {
    // TensorFlow Lite заголовок
    0x1c, 0x00, 0x00, 0x00, 0x54, 0x46, 0x4c, 0x33, 0x00, 0x00, 0x12, 0x00,
    0x1c, 0x00, 0x04, 0x00, 0x08, 0x00, 0x0c, 0x00, 0x10, 0x00, 0x14, 0x00,
    0x18, 0x00, 0x12, 0x00, 0x00, 0x00, 0x18, 0x0b, 0x00, 0x00, 0x20, 0x0b,
    0x00, 0x00, 0x28, 0x0b, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x6c, 0x00,
    
    // Упрощенная структура модели для демонстрации
    // В реальности здесь будут тысячи байт обученной модели
    0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 0xbc, 0x00, 0x00, 0x00, 0xe4, 0x00,
    0x00, 0x00, 0x0c, 0x01, 0x00, 0x00, 0x34, 0x01, 0x00, 0x00, 0x5c, 0x01,
    0x00, 0x00, 0x84, 0x01, 0x00, 0x00, 0xac, 0x01, 0x00, 0x00, 0xd4, 0x01,
    0x00, 0x00, 0xfc, 0x01, 0x00, 0x00, 0x24, 0x02, 0x00, 0x00, 0x4c, 0x02,
    
    // Веса и биасы (упрощенные для демо)
    0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x40, 0x3f,
    0x00, 0x00, 0x20, 0x3f, 0x00, 0x00, 0x60, 0x3f, 0x00, 0x00, 0x10, 0x3f,
    0x00, 0x00, 0x70, 0x3f, 0x00, 0x00, 0x30, 0x3f, 0x00, 0x00, 0x50, 0x3f,
    0x00, 0x00, 0x90, 0x3f, 0x00, 0x00, 0x88, 0x3f, 0x00, 0x00, 0x84, 0x3f,
    
    // Продолжение весов модели (паттерн повторяется)
    0x00, 0x00, 0x82, 0x3f, 0x00, 0x00, 0x86, 0x3f, 0x00, 0x00, 0x8a, 0x3f,
    0x00, 0x00, 0x8e, 0x3f, 0x00, 0x00, 0x92, 0x3f, 0x00, 0x00, 0x96, 0x3f,
    0x00, 0x00, 0x9a, 0x3f, 0x00, 0x00, 0x9e, 0x3f, 0x00, 0x00, 0xa2, 0x3f,
    0x00, 0x00, 0xa6, 0x3f, 0x00, 0x00, 0xaa, 0x3f, 0x00, 0x00, 0xae, 0x3f,
};

// Функция для получения данных модели
const unsigned char* get_voicex_model_data() {
    return voicex_model_data;
}

// Функция для получения размера модели
unsigned int get_voicex_model_size() {
    return voicex_model_data_len;
}

// Проверка валидности модели
bool validate_model_data() {
    // Проверка магических байтов TensorFlow Lite
    if (voicex_model_data_len < 8) return false;
    
    // Проверка заголовка "TFL3"
    if (voicex_model_data[4] != 0x54 || // 'T'
        voicex_model_data[5] != 0x46 || // 'F' 
        voicex_model_data[6] != 0x4c || // 'L'
        voicex_model_data[7] != 0x33) { // '3'
        return false;
    }
    
    return true;
}

// Метаданные модели
struct ModelMetadata {
    const char* version = "1.0.0-demo";
    const char* architecture = "autoencoder";
    int input_size = 512;
    int output_size = 256;
    const char* quantization = "float32";
    const char* created_date = "2024-01-20";
    const char* description = "VoiceX demo model for testing";
};

const ModelMetadata model_metadata;

#endif // VOICEX_MODEL_DATA_H